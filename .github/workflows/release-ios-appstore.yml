name: Release iOS App Store

on:
  workflow_call:
    inputs:
      upload:
        description: Upload to App Store Connect
        required: false
        type: boolean
        default: true
      submit_for_review:
        description: Submit build for review after upload
        required: false
        type: boolean
        default: true
      testflight_group:
        description: TestFlight external group for review-blocked uploads
        required: false
        type: string
        default: 'external_testing'
  workflow_dispatch:
    inputs:
      upload:
        description: Upload to App Store Connect
        required: false
        type: boolean
        default: true
      submit_for_review:
        description: Submit build for review after upload
        required: false
        type: boolean
        default: false
      testflight_group:
        description: TestFlight external group for review-blocked uploads
        required: false
        type: string
        default: 'external_testing'

permissions:
  contents: read

concurrency:
  group: release-ios-appstore-${{ github.ref }}
  cancel-in-progress: false

jobs:
  ios-appstore:
    runs-on: macos-15
    timeout-minutes: 90
    env:
      EXPECTED_TEAM_ID: 5X9JC5PL7T
      EXPECTED_BUNDLE_ID: tech.dongdongbh.mindwtr
      EXPECTED_WIDGET_BUNDLE_ID: tech.dongdongbh.mindwtr.MindwtrWidgets
      EXPECTED_APP_GROUP: group.tech.dongdongbh.mindwtr
      ANALYTICS_HEARTBEAT_URL: ${{ secrets.ANALYTICS_HEARTBEAT_URL }}
      DROPBOX_APP_KEY: ${{ vars.DROPBOX_APP_KEY || secrets.DROPBOX_APP_KEY }}
    steps:
      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4

      - name: Setup Ruby
        uses: ruby/setup-ruby@09a7688d3b55cf0e976497ff046b70949eeaccfd # v1
        with:
          ruby-version: '3.3'

      - name: Install Fastlane
        run: gem install fastlane --no-document

      - name: Select Xcode (iOS 26 SDK required)
        run: |
          set -euo pipefail
          XCODE_26_PATH="$(ls -d /Applications/Xcode_26*.app 2>/dev/null | sort -V | tail -n 1 || true)"
          if [ -n "${XCODE_26_PATH:-}" ]; then
            sudo xcode-select -s "$XCODE_26_PATH"
          else
            XCODE_FALLBACK_PATH="$(ls -d /Applications/Xcode*.app 2>/dev/null | sort -V | tail -n 1 || true)"
            if [ -n "${XCODE_FALLBACK_PATH:-}" ]; then
              echo "::warning::No Xcode_26*.app found; falling back to latest available: ${XCODE_FALLBACK_PATH}"
              sudo xcode-select -s "$XCODE_FALLBACK_PATH"
            else
              echo "::warning::No explicit Xcode*.app found; using runner default Xcode."
            fi
          fi

          echo "Selected DEVELOPER_DIR: $(xcode-select -p)"
          xcodebuild -version

          IOS_SDK_VERSION="$(xcodebuild -showsdks | awk '/-sdk iphoneos/{gsub(/iphoneos/, "", $NF); ver=$NF} END{print ver}')"
          if [ -z "${IOS_SDK_VERSION:-}" ]; then
            echo "::error::No iPhoneOS SDK found on runner. Current SDKs:"
            xcodebuild -showsdks
            exit 1
          fi

          IOS_SDK_MAJOR="${IOS_SDK_VERSION%%.*}"
          if ! [[ "${IOS_SDK_MAJOR}" =~ ^[0-9]+$ ]]; then
            echo "::error::Unable to parse iPhoneOS SDK version: ${IOS_SDK_VERSION}"
            xcodebuild -showsdks
            exit 1
          fi

          if [ "${IOS_SDK_MAJOR}" -lt 26 ]; then
            echo "::error::Detected iPhoneOS SDK ${IOS_SDK_VERSION}. App Store Connect requires iOS 26 SDK or later (ITMS-90725)."
            echo "::error::Install/select Xcode 26+ on the runner before uploading."
            exit 1
          fi

          echo "Using iPhoneOS SDK ${IOS_SDK_VERSION}"

      - name: Setup Node.js
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4
        with:
          node-version: 20

      - name: Setup Bun
        uses: oven-sh/setup-bun@3d267786b128fe76c2f16a390aa2448b815359f3 # v2
        with:
          bun-version: "1.x"

      - name: Install dependencies
        run: bun install

      - name: Validate required secrets
        env:
          IOS_DISTRIBUTION_CERT: ${{ secrets.IOS_DISTRIBUTION_CERT }}
          IOS_DISTRIBUTION_CERT_PWD: ${{ secrets.IOS_DISTRIBUTION_CERT_PWD }}
          IOS_PROVISIONING_PROFILE: ${{ secrets.IOS_PROVISIONING_PROFILE }}
          IOS_WIDGET_PROVISIONING_PROFILE: ${{ secrets.IOS_WIDGET_PROVISIONING_PROFILE }}
          IOS_ASC_KEY_ID: ${{ secrets.IOS_ASC_KEY_ID }}
          IOS_ASC_ISSUER_ID: ${{ secrets.IOS_ASC_ISSUER_ID }}
          IOS_ASC_PRIVATE_KEY: ${{ secrets.IOS_ASC_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          missing=0
          for key in IOS_DISTRIBUTION_CERT IOS_DISTRIBUTION_CERT_PWD IOS_PROVISIONING_PROFILE; do
            if [ -z "${!key:-}" ]; then
              echo "::error::Missing required secret: $key"
              missing=1
            fi
          done
          if [ -z "${IOS_WIDGET_PROVISIONING_PROFILE:-}" ]; then
            echo "::warning::IOS_WIDGET_PROVISIONING_PROFILE is not set. Falling back to IOS_PROVISIONING_PROFILE for MindwtrWidgets."
          fi
          for key in IOS_ASC_KEY_ID IOS_ASC_ISSUER_ID IOS_ASC_PRIVATE_KEY; do
            if [ -z "${!key:-}" ]; then
              echo "::error::Missing required App Store Connect API secret: $key"
              missing=1
            fi
          done
          if [ "$missing" -ne 0 ]; then
            exit 1
          fi

      - name: Resolve iOS version metadata
        env:
          IOS_ASC_KEY_ID: ${{ secrets.IOS_ASC_KEY_ID }}
          IOS_ASC_ISSUER_ID: ${{ secrets.IOS_ASC_ISSUER_ID }}
          IOS_ASC_PRIVATE_KEY: ${{ secrets.IOS_ASC_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          APP_VERSION="$(jq -r '.expo.version // empty' apps/mobile/app.json)"
          APP_BUILD_NUMBER_BASE="$(jq -r '.expo.ios.buildNumber // "0"' apps/mobile/app.json)"
          if [ -z "${APP_VERSION}" ]; then
            echo "::error::Missing expo.version in apps/mobile/app.json"
            exit 1
          fi

          APPSTORE_APP_ID=""
          REMOTE_MAX_BUILD=0
          REMOTE_LOOKUP_STATUS="skipped"
          if [ -n "${IOS_ASC_KEY_ID:-}" ] && [ -n "${IOS_ASC_ISSUER_ID:-}" ] && [ -n "${IOS_ASC_PRIVATE_KEY:-}" ]; then
            ASC_KEY_ID="$(printf '%s' "$IOS_ASC_KEY_ID" | tr -d '\r\n\t ')"
            ASC_ISSUER_ID="$(printf '%s' "$IOS_ASC_ISSUER_ID" | tr -d '\r\n\t ')"
            if ! printf '%s' "$ASC_KEY_ID" | grep -Eq '^[A-Z0-9]{10}$'; then
              echo "::warning::IOS_ASC_KEY_ID format looks invalid after trimming (expected 10 chars, e.g. ABCD123456)."
            fi
            if ! printf '%s' "$ASC_ISSUER_ID" | grep -Eq '^[0-9a-fA-F-]{36}$'; then
              echo "::warning::IOS_ASC_ISSUER_ID format looks invalid after trimming (expected UUID)."
            fi
            KEY_PATH="$RUNNER_TEMP/ios-asc-key.p8"
            bash scripts/ci/write-asc-private-key.sh "$IOS_ASC_PRIVATE_KEY" "$KEY_PATH"

            if ! openssl pkey -in "$KEY_PATH" -noout >/dev/null 2>&1; then
              echo "::warning::IOS_ASC_PRIVATE_KEY is not a valid .p8 key; skipping remote max build lookup."
              REMOTE_LOOKUP_STATUS="invalid_key"
            else
              ASC_API_TMP_PREFIX="asc-api"
              source scripts/ci/asc-api-utils.sh

              if ! ASC_TOKEN="$(
                node scripts/ci/generate-asc-jwt.js "$ASC_KEY_ID" "$ASC_ISSUER_ID" "$KEY_PATH"
              )"; then
                echo "::warning::Failed to generate App Store Connect JWT from IOS_ASC_* secrets."
                REMOTE_LOOKUP_STATUS="invalid_jwt"
              fi

              APP_LOOKUP_JSON_FILE="$RUNNER_TEMP/asc-app-lookup.json"
              if [ "${REMOTE_LOOKUP_STATUS}" != "invalid_jwt" ]; then
                if api_get "$APP_LOOKUP_JSON_FILE" -G \
                  -H "Authorization: Bearer ${ASC_TOKEN}" \
                  --data-urlencode "filter[bundleId]=${EXPECTED_BUNDLE_ID}" \
                  --data-urlencode "limit=1" \
                  "https://api.appstoreconnect.apple.com/v1/apps"; then
                  APPSTORE_APP_ID="$(jq -r '.data[0].id // empty' "$APP_LOOKUP_JSON_FILE")"
                  if [ -n "${APPSTORE_APP_ID}" ]; then
                    BUILDS_JSON_FILE="$RUNNER_TEMP/asc-builds-page.json"
                    if api_get "$BUILDS_JSON_FILE" -G \
                      -H "Authorization: Bearer ${ASC_TOKEN}" \
                      --data-urlencode "filter[app]=${APPSTORE_APP_ID}" \
                      --data-urlencode "limit=200" \
                      "https://api.appstoreconnect.apple.com/v1/builds"; then
                      while : ; do
                        PAGE_MAX="$(jq -r '[.data[]?.attributes.version | select(type=="string") | select(test("^[0-9]+$")) | tonumber] | max // 0' "$BUILDS_JSON_FILE")"
                        if [ "${PAGE_MAX}" -gt "${REMOTE_MAX_BUILD}" ]; then
                          REMOTE_MAX_BUILD="${PAGE_MAX}"
                        fi
                        NEXT_URL="$(jq -r '.links.next // empty' "$BUILDS_JSON_FILE")"
                        if [ -z "${NEXT_URL}" ]; then
                          REMOTE_LOOKUP_STATUS="ok"
                          break
                        fi
                        if ! api_get "$BUILDS_JSON_FILE" -g -H "Authorization: Bearer ${ASC_TOKEN}" "$NEXT_URL"; then
                          REMOTE_LOOKUP_STATUS="api_error"
                          break
                        fi
                      done
                    else
                      REMOTE_LOOKUP_STATUS="api_error"
                    fi
                  else
                    echo "::warning::App Store Connect app lookup returned no app for bundle id ${EXPECTED_BUNDLE_ID}."
                    REMOTE_LOOKUP_STATUS="no_app"
                  fi
                else
                  REMOTE_LOOKUP_STATUS="api_error"
                fi
              fi
            fi
          else
            echo "::warning::Remote max build lookup skipped. Set IOS_ASC_KEY_ID / IOS_ASC_ISSUER_ID / IOS_ASC_PRIVATE_KEY secrets."
          fi

          LOCAL_MIN_BUILD=1
          if [[ "${APP_BUILD_NUMBER_BASE}" =~ ^[0-9]+$ ]]; then
            LOCAL_MIN_BUILD="$((APP_BUILD_NUMBER_BASE + 1))"
          fi
          REMOTE_MIN_BUILD="$((REMOTE_MAX_BUILD + 1))"
          FINAL_BUILD_NUMBER="${LOCAL_MIN_BUILD}"
          if [ "${REMOTE_MIN_BUILD}" -gt "${FINAL_BUILD_NUMBER}" ]; then
            FINAL_BUILD_NUMBER="${REMOTE_MIN_BUILD}"
          fi

          echo "APP_VERSION=${APP_VERSION}" >> "$GITHUB_ENV"
          echo "APP_BUILD_NUMBER=${FINAL_BUILD_NUMBER}" >> "$GITHUB_ENV"
          echo "APPSTORE_APP_ID=${APPSTORE_APP_ID:-}" >> "$GITHUB_ENV"
          echo "Resolved iOS build number: ${FINAL_BUILD_NUMBER} (remote max: ${REMOTE_MAX_BUILD}, remote lookup: ${REMOTE_LOOKUP_STATUS}, local base: ${APP_BUILD_NUMBER_BASE})"

      - name: Import iOS distribution certificate
        env:
          IOS_DISTRIBUTION_CERT: ${{ secrets.IOS_DISTRIBUTION_CERT }}
          IOS_DISTRIBUTION_CERT_PWD: ${{ secrets.IOS_DISTRIBUTION_CERT_PWD }}
          IOS_SIGNING_IDENTITY: ${{ secrets.IOS_SIGNING_IDENTITY }}
        run: |
          set -euo pipefail


          KEYCHAIN_PATH="$RUNNER_TEMP/mindwtr-ios.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -base64 24)"
          CERT_PATH="$RUNNER_TEMP/ios-distribution.p12"

          bash scripts/ci/decode-base64-to-file.sh "$IOS_DISTRIBUTION_CERT" "$CERT_PATH"
          if ! openssl pkcs12 -in "$CERT_PATH" -passin "pass:${IOS_DISTRIBUTION_CERT_PWD}" -nokeys -clcerts >/dev/null 2>&1; then
            echo "::error::Unable to open IOS_DISTRIBUTION_CERT with IOS_DISTRIBUTION_CERT_PWD."
            exit 1
          fi

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          LOGIN_KEYCHAIN="$HOME/Library/Keychains/login.keychain-db"
          if [ -f "$LOGIN_KEYCHAIN" ]; then
            security list-keychains -d user -s "$KEYCHAIN_PATH" "$LOGIN_KEYCHAIN" "/Library/Keychains/System.keychain"
          else
            security list-keychains -d user -s "$KEYCHAIN_PATH" "/Library/Keychains/System.keychain"
          fi
          security default-keychain -s "$KEYCHAIN_PATH"

          security import "$CERT_PATH" -k "$KEYCHAIN_PATH" -P "$IOS_DISTRIBUTION_CERT_PWD" -A -T /usr/bin/codesign -T /usr/bin/security -T /usr/bin/xcodebuild
          security set-key-partition-list -S apple-tool:,apple:,codesign:,xcodebuild:,security: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          RESOLVED_IDENTITY="${IOS_SIGNING_IDENTITY:-}"
          if [ -z "${RESOLVED_IDENTITY}" ]; then
            RESOLVED_IDENTITY="$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | sed -n 's/.*"\(Apple Distribution:.*\)".*/\1/p' | head -n 1)"
          fi
          if [ -z "${RESOLVED_IDENTITY}" ]; then
            echo "::error::Could not resolve Apple Distribution identity from imported certificate."
            security find-identity -v -p codesigning "$KEYCHAIN_PATH" || true
            exit 1
          fi

          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> "$GITHUB_ENV"
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> "$GITHUB_ENV"
          echo "IOS_SIGNING_IDENTITY=$RESOLVED_IDENTITY" >> "$GITHUB_ENV"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH" || true

      - name: Install and validate provisioning profile
        env:
          IOS_PROVISIONING_PROFILE: ${{ secrets.IOS_PROVISIONING_PROFILE }}
          IOS_WIDGET_PROVISIONING_PROFILE: ${{ secrets.IOS_WIDGET_PROVISIONING_PROFILE }}
        run: |
          set -euo pipefail

          profile_field() {
            local plist_path="$1"
            local key_path="$2"
            /usr/libexec/PlistBuddy -c "Print $key_path" "$plist_path" 2>/dev/null || true
          }

          verify_profile_bundle() {
            local app_id="$1"
            local expected_bundle="$2"
            local profile_label="$3"
            local expected_id="${EXPECTED_TEAM_ID}.${expected_bundle}"
            local wildcard_id="${EXPECTED_TEAM_ID}.*"
            if [ "$app_id" != "$expected_id" ] && [ "$app_id" != "$wildcard_id" ]; then
              echo "::error::${profile_label} application-identifier (${app_id}) does not match expected (${expected_id}) or wildcard (${wildcard_id})."
              exit 1
            fi
          }

          APP_PROFILE_PATH="$RUNNER_TEMP/mindwtr-ios-app.mobileprovision"
          APP_PROFILE_PLIST="$RUNNER_TEMP/mindwtr-ios-app-profile.plist"
          WIDGET_PROFILE_PATH="$RUNNER_TEMP/mindwtr-ios-widget.mobileprovision"
          WIDGET_PROFILE_PLIST="$RUNNER_TEMP/mindwtr-ios-widget-profile.plist"

          bash scripts/ci/decode-base64-to-file.sh "$IOS_PROVISIONING_PROFILE" "$APP_PROFILE_PATH"
          security cms -D -i "$APP_PROFILE_PATH" > "$APP_PROFILE_PLIST"
          if [ -n "${IOS_WIDGET_PROVISIONING_PROFILE:-}" ]; then
            bash scripts/ci/decode-base64-to-file.sh "$IOS_WIDGET_PROVISIONING_PROFILE" "$WIDGET_PROFILE_PATH"
          else
            cp "$APP_PROFILE_PATH" "$WIDGET_PROFILE_PATH"
          fi
          security cms -D -i "$WIDGET_PROFILE_PATH" > "$WIDGET_PROFILE_PLIST"

          APP_PROFILE_UUID="$(profile_field "$APP_PROFILE_PLIST" "UUID")"
          APP_PROFILE_NAME="$(profile_field "$APP_PROFILE_PLIST" "Name")"
          APP_PROFILE_TEAM_ID="$(profile_field "$APP_PROFILE_PLIST" "TeamIdentifier:0")"
          APP_PROFILE_APP_ID="$(profile_field "$APP_PROFILE_PLIST" "Entitlements:application-identifier")"
          APP_PROFILE_GROUPS="$(profile_field "$APP_PROFILE_PLIST" "Entitlements:com.apple.security.application-groups")"

          if [ "$APP_PROFILE_TEAM_ID" != "$EXPECTED_TEAM_ID" ]; then
            echo "::error::App profile TeamIdentifier (${APP_PROFILE_TEAM_ID}) does not match expected team (${EXPECTED_TEAM_ID})."
            exit 1
          fi
          verify_profile_bundle "$APP_PROFILE_APP_ID" "$EXPECTED_BUNDLE_ID" "App profile"
          if ! printf '%s\n' "$APP_PROFILE_GROUPS" | grep -Fq "$EXPECTED_APP_GROUP"; then
            echo "::error::App profile (${APP_PROFILE_NAME}) is missing App Group ${EXPECTED_APP_GROUP}. Recreate the profile with App Groups enabled and re-upload IOS_PROVISIONING_PROFILE."
            exit 1
          fi

          WIDGET_PROFILE_UUID="$(profile_field "$WIDGET_PROFILE_PLIST" "UUID")"
          WIDGET_PROFILE_NAME="$(profile_field "$WIDGET_PROFILE_PLIST" "Name")"
          WIDGET_PROFILE_TEAM_ID="$(profile_field "$WIDGET_PROFILE_PLIST" "TeamIdentifier:0")"
          WIDGET_PROFILE_APP_ID="$(profile_field "$WIDGET_PROFILE_PLIST" "Entitlements:application-identifier")"
          WIDGET_PROFILE_GROUPS="$(profile_field "$WIDGET_PROFILE_PLIST" "Entitlements:com.apple.security.application-groups")"

          if [ "$WIDGET_PROFILE_TEAM_ID" != "$EXPECTED_TEAM_ID" ]; then
            echo "::error::Widget profile TeamIdentifier (${WIDGET_PROFILE_TEAM_ID}) does not match expected team (${EXPECTED_TEAM_ID})."
            exit 1
          fi
          verify_profile_bundle "$WIDGET_PROFILE_APP_ID" "$EXPECTED_WIDGET_BUNDLE_ID" "Widget profile"
          if ! printf '%s\n' "$WIDGET_PROFILE_GROUPS" | grep -Fq "$EXPECTED_APP_GROUP"; then
            echo "::error::Widget profile (${WIDGET_PROFILE_NAME}) is missing App Group ${EXPECTED_APP_GROUP}. Recreate the extension profile with App Groups enabled and re-upload IOS_WIDGET_PROVISIONING_PROFILE."
            exit 1
          fi

          mkdir -p "$HOME/Library/MobileDevice/Provisioning Profiles"
          cp "$APP_PROFILE_PATH" "$HOME/Library/MobileDevice/Provisioning Profiles/$APP_PROFILE_UUID.mobileprovision"
          cp "$WIDGET_PROFILE_PATH" "$HOME/Library/MobileDevice/Provisioning Profiles/$WIDGET_PROFILE_UUID.mobileprovision"

          echo "APP_PROFILE_UUID=$APP_PROFILE_UUID" >> "$GITHUB_ENV"
          echo "APP_PROFILE_NAME=$APP_PROFILE_NAME" >> "$GITHUB_ENV"
          echo "APP_PROFILE_TEAM_ID=$APP_PROFILE_TEAM_ID" >> "$GITHUB_ENV"
          echo "WIDGET_PROFILE_UUID=$WIDGET_PROFILE_UUID" >> "$GITHUB_ENV"
          echo "WIDGET_PROFILE_NAME=$WIDGET_PROFILE_NAME" >> "$GITHUB_ENV"

      - name: Generate iOS native project if missing
        run: |
          set -euo pipefail
          if [ ! -d apps/mobile/ios ]; then
            cd apps/mobile
            npx expo prebuild --platform ios --non-interactive --no-install
          fi

      - name: Cache CocoaPods dependencies
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4
        with:
          path: |
            apps/mobile/ios/Pods
            ~/Library/Caches/CocoaPods
            ~/.cocoapods/repos
          key: ${{ runner.os }}-cocoapods-${{ hashFiles('apps/mobile/ios/Podfile.lock') }}
          restore-keys: |
            ${{ runner.os }}-cocoapods-

      - name: Install CocoaPods dependencies
        run: |
          set -euo pipefail
          if [ ! -d apps/mobile/ios ]; then
            echo "::error::apps/mobile/ios still missing after prebuild."
            exit 1
          fi
          cd apps/mobile/ios
          pod install

      - name: Apply iOS version and build number
        run: |
          set -euo pipefail
          APP_INFO_PLIST="apps/mobile/ios/Mindwtr/Info.plist"
          if [ ! -f "$APP_INFO_PLIST" ]; then
            echo "::error::Info.plist not found at $APP_INFO_PLIST"
            exit 1
          fi
          /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $APP_VERSION" "$APP_INFO_PLIST" \
            || /usr/libexec/PlistBuddy -c "Add :CFBundleShortVersionString string $APP_VERSION" "$APP_INFO_PLIST"
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $APP_BUILD_NUMBER" "$APP_INFO_PLIST" \
            || /usr/libexec/PlistBuddy -c "Add :CFBundleVersion string $APP_BUILD_NUMBER" "$APP_INFO_PLIST"
          echo "Info.plist version: $(/usr/libexec/PlistBuddy -c 'Print :CFBundleShortVersionString' "$APP_INFO_PLIST")"
          echo "Info.plist build: $(/usr/libexec/PlistBuddy -c 'Print :CFBundleVersion' "$APP_INFO_PLIST")"

      - name: Prepare ExportOptions.plist
        env:
          IOS_EXPORT_OPTIONS: ${{ secrets.IOS_EXPORT_OPTIONS }}
        run: |
          set -euo pipefail


          EXPORT_OPTIONS_PATH="$RUNNER_TEMP/ExportOptions.plist"
          if [ -n "${IOS_EXPORT_OPTIONS:-}" ]; then
            bash scripts/ci/decode-base64-to-file.sh "$IOS_EXPORT_OPTIONS" "$EXPORT_OPTIONS_PATH"
          else
            {
              printf '%s\n' '<?xml version="1.0" encoding="UTF-8"?>'
              printf '%s\n' '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">'
              printf '%s\n' '<plist version="1.0">'
              printf '%s\n' '<dict>'
              printf '%s\n' '    <key>method</key>'
              printf '%s\n' '    <string>app-store-connect</string>'
              printf '%s\n' '    <key>destination</key>'
              printf '%s\n' '    <string>export</string>'
              printf '%s\n' '    <key>signingStyle</key>'
              printf '%s\n' '    <string>manual</string>'
              printf '%s\n' '    <key>teamID</key>'
              printf '    <string>%s</string>\n' "$APP_PROFILE_TEAM_ID"
              printf '%s\n' '    <key>provisioningProfiles</key>'
              printf '%s\n' '    <dict>'
              printf '        <key>%s</key>\n' "$EXPECTED_BUNDLE_ID"
              printf '        <string>%s</string>\n' "$APP_PROFILE_NAME"
              printf '        <key>%s</key>\n' "$EXPECTED_WIDGET_BUNDLE_ID"
              printf '        <string>%s</string>\n' "$WIDGET_PROFILE_NAME"
              printf '%s\n' '    </dict>'
              printf '%s\n' '    <key>stripSwiftSymbols</key>'
              printf '%s\n' '    <true/>'
              printf '%s\n' '    <key>uploadSymbols</key>'
              printf '%s\n' '    <true/>'
              printf '%s\n' '</dict>'
              printf '%s\n' '</plist>'
            } > "$EXPORT_OPTIONS_PATH"
          fi

          # Normalize ExportOptions for CI signing so stale IOS_EXPORT_OPTIONS
          # secrets cannot override app/widget provisioning profile mapping.
          /usr/libexec/PlistBuddy -c "Set :method app-store-connect" "$EXPORT_OPTIONS_PATH" \
            || /usr/libexec/PlistBuddy -c "Add :method string app-store-connect" "$EXPORT_OPTIONS_PATH"
          /usr/libexec/PlistBuddy -c "Set :destination export" "$EXPORT_OPTIONS_PATH" \
            || /usr/libexec/PlistBuddy -c "Add :destination string export" "$EXPORT_OPTIONS_PATH"
          /usr/libexec/PlistBuddy -c "Set :signingStyle manual" "$EXPORT_OPTIONS_PATH" \
            || /usr/libexec/PlistBuddy -c "Add :signingStyle string manual" "$EXPORT_OPTIONS_PATH"
          /usr/libexec/PlistBuddy -c "Set :teamID $APP_PROFILE_TEAM_ID" "$EXPORT_OPTIONS_PATH" \
            || /usr/libexec/PlistBuddy -c "Add :teamID string $APP_PROFILE_TEAM_ID" "$EXPORT_OPTIONS_PATH"

          /usr/libexec/PlistBuddy -c "Delete :provisioningProfiles" "$EXPORT_OPTIONS_PATH" || true
          /usr/libexec/PlistBuddy -c "Add :provisioningProfiles dict" "$EXPORT_OPTIONS_PATH"
          /usr/libexec/PlistBuddy -c "Add :provisioningProfiles:$EXPECTED_BUNDLE_ID string $APP_PROFILE_NAME" "$EXPORT_OPTIONS_PATH"
          /usr/libexec/PlistBuddy -c "Add :provisioningProfiles:$EXPECTED_WIDGET_BUNDLE_ID string $WIDGET_PROFILE_NAME" "$EXPORT_OPTIONS_PATH"

          echo "EXPORT_OPTIONS_PATH=$EXPORT_OPTIONS_PATH" >> "$GITHUB_ENV"

      - name: Apply CI signing settings to Xcode project
        run: |
          set -euo pipefail
          export PROJECT_FILE="apps/mobile/ios/Mindwtr.xcodeproj/project.pbxproj"
          ruby <<'RUBY'
          project_file = ENV.fetch('PROJECT_FILE')
          targets = {
            'Mindwtr' => {
              bundle: ENV.fetch('EXPECTED_BUNDLE_ID'),
              profile_name: ENV.fetch('APP_PROFILE_NAME'),
              profile_uuid: ENV.fetch('APP_PROFILE_UUID')
            },
            'MindwtrWidgets' => {
              bundle: ENV.fetch('EXPECTED_WIDGET_BUNDLE_ID'),
              profile_name: ENV.fetch('WIDGET_PROFILE_NAME'),
              profile_uuid: ENV.fetch('WIDGET_PROFILE_UUID')
            }
          }
          team_id = ENV.fetch('EXPECTED_TEAM_ID')
          signing_identity = ENV.fetch('IOS_SIGNING_IDENTITY')

          lines = File.readlines(project_file, chomp: false)

          # Map XCBuildConfiguration IDs to target names via XCConfigurationList entries.
          config_to_target = {}
          i = 0
          while i < lines.length
            m = lines[i].match(/^\s*([A-F0-9]{24})\s*\/\*\s*Build configuration list for PBXNativeTarget \"([^\"]+)\"\s*\*\/\s*=\s*\{/)
            if m
              target_name = m[2]
              if targets.key?(target_name)
                j = i + 1
                in_build_configs = false
                while j < lines.length
                  in_build_configs = true if lines[j].match?(/^\s*buildConfigurations\s*=\s*\(/)
                  if in_build_configs
                    lines[j].scan(/([A-F0-9]{24})\s*\/\*.*?\*\//) do |cfg|
                      config_to_target[cfg[0]] = target_name
                    end
                    break if lines[j].match?(/^\s*\);\s*$/)
                  end
                  break if lines[j].match?(/^\s*};\s*$/) && !in_build_configs
                  j += 1
                end
              end
            end
            i += 1
          end

          if config_to_target.empty?
            puts "DEBUG: Could not map any build configurations to Mindwtr targets."
            lines.each do |line|
              if line.include?('Build configuration list for PBXNativeTarget')
                puts "DEBUG: #{line.strip}"
              end
            end
            abort("No target build configuration IDs resolved in #{project_file}.")
          end

          modified_blocks = 0
          i = 0
          while i < lines.length
            m = lines[i].match(/^\s*([A-F0-9]{24})\s*\/\*.*?\*\/\s*=\s*\{/)
            if m
              config_id = m[1]
              target_name = config_to_target[config_id]
              if target_name
                target_info = targets.fetch(target_name)

                # Find buildSettings block boundaries for this XCBuildConfiguration block.
                bs_start = nil
                j = i + 1
                while j < lines.length
                  if lines[j].match?(/^\s*buildSettings\s*=\s*\{/)
                    bs_start = j
                    break
                  end
                  break if lines[j].match?(/^\s*};\s*$/)
                  j += 1
                end

                if bs_start
                  brace_depth = lines[bs_start].count('{') - lines[bs_start].count('}')
                  k = bs_start + 1
                  while k < lines.length && brace_depth > 0
                    brace_depth += lines[k].count('{') - lines[k].count('}')
                    k += 1
                  end
                  bs_end = k - 1

                  if brace_depth == 0 && bs_end > bs_start
                    block = lines[(bs_start + 1)...bs_end]
                    indent = block.find { |line| line.match?(/\S/) }&.match(/^\s*/)&.to_s || "\t\t\t\t\t"
                    updates = {
                      'CODE_SIGN_STYLE' => 'Manual',
                      'DEVELOPMENT_TEAM' => team_id,
                      'CODE_SIGN_IDENTITY' => "\"#{signing_identity}\"",
                      'PROVISIONING_PROFILE_SPECIFIER' => "\"#{target_info[:profile_name]}\"",
                      'PROVISIONING_PROFILE' => "\"#{target_info[:profile_uuid]}\"",
                      'PRODUCT_BUNDLE_IDENTIFIER' => "\"#{target_info[:bundle]}\""
                    }

                    updates.each do |key, value|
                      replacement = "#{indent}#{key} = #{value};\n"
                      idx = block.index { |line| line.match?(/^\s*#{Regexp.escape(key)}\s*=/) }
                      if idx
                        block[idx] = replacement
                      else
                        block << replacement
                      end
                    end

                    lines[(bs_start + 1)...bs_end] = block
                    modified_blocks += 1
                  end
                end
              end
            end
            i += 1
          end

          if modified_blocks == 0
            abort("No signing blocks were updated in #{project_file}.")
          end

          File.write(project_file, lines.join)
          puts "Updated signing settings in #{modified_blocks} buildSettings blocks."
          RUBY
          if command -v rg >/dev/null 2>&1; then
            rg -n 'PRODUCT_BUNDLE_IDENTIFIER = "|CODE_SIGN_STYLE =|DEVELOPMENT_TEAM =|CODE_SIGN_IDENTITY =|PROVISIONING_PROFILE_SPECIFIER =' "$PROJECT_FILE" | sed -n '1,120p'
          else
            grep -nE 'PRODUCT_BUNDLE_IDENTIFIER = "|CODE_SIGN_STYLE =|DEVELOPMENT_TEAM =|CODE_SIGN_IDENTITY =|PROVISIONING_PROFILE_SPECIFIER =' "$PROJECT_FILE" | sed -n '1,120p'
          fi

      - name: Archive iOS app
        timeout-minutes: 25
        run: |
          set -euo pipefail
          ARCHIVE_PATH="$RUNNER_TEMP/Mindwtr.xcarchive"
          ARCHIVE_LOG="$RUNNER_TEMP/ios-xcodebuild-archive.log"
          echo "ARCHIVE_LOG=$ARCHIVE_LOG" >> "$GITHUB_ENV"

          set +e
          xcodebuild \
            -workspace "apps/mobile/ios/Mindwtr.xcworkspace" \
            -scheme "Mindwtr" \
            -configuration "Release" \
            -sdk "iphoneos" \
            -destination "generic/platform=iOS" \
            -archivePath "$ARCHIVE_PATH" \
            DEVELOPMENT_TEAM="$EXPECTED_TEAM_ID" \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGN_IDENTITY="$IOS_SIGNING_IDENTITY" \
            MARKETING_VERSION="$APP_VERSION" \
            CURRENT_PROJECT_VERSION="$APP_BUILD_NUMBER" \
            clean archive >"$ARCHIVE_LOG" 2>&1
          ARCHIVE_STATUS=$?
          set -e

          if [ "$ARCHIVE_STATUS" -ne 0 ]; then
            echo "::group::xcodebuild archive error summary"
            grep -E "(^| )error:|\\*\\* ARCHIVE FAILED \\*\\*|The following build commands failed|Provisioning|CodeSign|No profiles|conflicting provisioning settings" "$ARCHIVE_LOG" | tail -n 200 || true
            echo "::endgroup::"
            echo "::group::xcodebuild archive tail (last 200 lines)"
            tail -n 200 "$ARCHIVE_LOG" || true
            echo "::endgroup::"
            exit "$ARCHIVE_STATUS"
          fi

          ARCHIVE_INFO_PLIST="$ARCHIVE_PATH/Products/Applications/Mindwtr.app/Info.plist"
          if [ ! -f "$ARCHIVE_INFO_PLIST" ]; then
            echo "::error::Archived app Info.plist not found: $ARCHIVE_INFO_PLIST"
            exit 1
          fi
          ARCHIVE_BUILD_NUMBER="$(/usr/libexec/PlistBuddy -c 'Print :CFBundleVersion' "$ARCHIVE_INFO_PLIST")"
          ARCHIVE_VERSION="$(/usr/libexec/PlistBuddy -c 'Print :CFBundleShortVersionString' "$ARCHIVE_INFO_PLIST")"
          echo "Archived app version: ${ARCHIVE_VERSION}"
          echo "Archived app build: ${ARCHIVE_BUILD_NUMBER}"
          if [ "$ARCHIVE_BUILD_NUMBER" != "$APP_BUILD_NUMBER" ]; then
            echo "::error::Archive build number mismatch (expected $APP_BUILD_NUMBER, got $ARCHIVE_BUILD_NUMBER)."
            exit 1
          fi
          echo "ARCHIVE_PATH=$ARCHIVE_PATH" >> "$GITHUB_ENV"

      - name: Export IPA
        timeout-minutes: 10
        run: |
          set -euo pipefail
          EXPORT_PATH="$RUNNER_TEMP/ios-export"
          EXPORT_LOG="$RUNNER_TEMP/ios-xcodebuild-export.log"
          echo "EXPORT_LOG=$EXPORT_LOG" >> "$GITHUB_ENV"

          set +e
          xcodebuild -exportArchive \
            -archivePath "$ARCHIVE_PATH" \
            -exportPath "$EXPORT_PATH" \
            -exportOptionsPlist "$EXPORT_OPTIONS_PATH" >"$EXPORT_LOG" 2>&1
          EXPORT_STATUS=$?
          set -e

          if [ "$EXPORT_STATUS" -ne 0 ]; then
            echo "::group::xcodebuild export error summary"
            grep -E "(^| )error:|\\*\\* EXPORT FAILED \\*\\*|The following build commands failed|Provisioning|CodeSign|No profiles" "$EXPORT_LOG" | tail -n 200 || true
            echo "::endgroup::"
            echo "::group::xcodebuild export tail (last 200 lines)"
            tail -n 200 "$EXPORT_LOG" || true
            echo "::endgroup::"
            exit "$EXPORT_STATUS"
          fi

          IPA_PATH="$(find "$EXPORT_PATH" -maxdepth 1 -name '*.ipa' | head -n 1)"
          if [ -z "${IPA_PATH:-}" ]; then
            echo "::error::IPA was not generated."
            exit 1
          fi
          echo "IPA_PATH=$IPA_PATH" >> "$GITHUB_ENV"
          ls -la "$EXPORT_PATH"

      - name: Verify IPA code-sign entitlements
        run: |
          set -euo pipefail
          IPA_INSPECT_DIR="$RUNNER_TEMP/ios-ipa-inspect"
          rm -rf "$IPA_INSPECT_DIR"
          mkdir -p "$IPA_INSPECT_DIR"
          unzip -q "$IPA_PATH" -d "$IPA_INSPECT_DIR"

          APP_PATH="$(find "$IPA_INSPECT_DIR/Payload" -maxdepth 1 -name '*.app' | head -n 1)"
          if [ -z "${APP_PATH:-}" ]; then
            echo "::error::Unable to locate .app payload inside IPA."
            exit 1
          fi

          WIDGET_PATH="$APP_PATH/PlugIns/MindwtrWidgets.appex"
          if [ ! -d "$WIDGET_PATH" ]; then
            echo "::error::Widget extension not found in IPA at $WIDGET_PATH."
            exit 1
          fi

          APP_ENTITLEMENTS="$RUNNER_TEMP/ios-app-entitlements.plist"
          WIDGET_ENTITLEMENTS="$RUNNER_TEMP/ios-widget-entitlements.plist"

          codesign -d --entitlements :- "$APP_PATH" > "$APP_ENTITLEMENTS" 2>/dev/null || true
          codesign -d --entitlements :- "$WIDGET_PATH" > "$WIDGET_ENTITLEMENTS" 2>/dev/null || true

          if ! grep -q "<plist" "$APP_ENTITLEMENTS"; then
            echo "::error::App bundle is missing signed entitlements."
            exit 1
          fi

          if ! grep -q "<plist" "$WIDGET_ENTITLEMENTS"; then
            echo "::error::Widget extension is missing signed entitlements."
            echo "::error::Ensure archive/export are code-signed for MindwtrWidgets (bundle $EXPECTED_WIDGET_BUNDLE_ID) with a valid provisioning profile."
            exit 1
          fi

          if ! grep -q "$EXPECTED_APP_GROUP" "$APP_ENTITLEMENTS"; then
            echo "::error::App entitlements missing expected App Group: $EXPECTED_APP_GROUP."
            exit 1
          fi

          if ! grep -q "$EXPECTED_APP_GROUP" "$WIDGET_ENTITLEMENTS"; then
            echo "::error::Widget entitlements missing expected App Group: $EXPECTED_APP_GROUP."
            exit 1
          fi


      - name: Upload iOS xcodebuild logs
        if: always()
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: mindwtr-ios-xcodebuild-logs
          path: ${{ runner.temp }}/ios-xcodebuild-*.log
          if-no-files-found: warn
          retention-days: 28

      - name: Prepare Fastlane metadata
        if: ${{ inputs.upload }}
        env:
          RELEASE_BODY: ${{ github.event.release.body || '' }}
          APP_SUPPORT_URL: "https://github.com/dongdongbh/Mindwtr/issues"
          APP_MARKETING_URL: "https://github.com/dongdongbh/Mindwtr"
        run: |
          set -euo pipefail
          export FASTLANE_METADATA_DIR="$RUNNER_TEMP/fastlane_metadata"
          scripts/ci/prepare-fastlane-metadata.sh
          echo "FASTLANE_METADATA_PATH=$FASTLANE_METADATA_DIR" >> "$GITHUB_ENV"

      - name: Resolve App Store review submission flag
        if: ${{ inputs.upload }}
        timeout-minutes: 10
        env:
          IOS_ASC_KEY_ID: ${{ secrets.IOS_ASC_KEY_ID }}
          IOS_ASC_ISSUER_ID: ${{ secrets.IOS_ASC_ISSUER_ID }}
          IOS_ASC_PRIVATE_KEY: ${{ secrets.IOS_ASC_PRIVATE_KEY }}
          REQUESTED_SUBMIT_FOR_REVIEW: ${{ inputs.submit_for_review && 'true' || 'false' }}
        run: |
          set -euo pipefail

          EFFECTIVE_SUBMIT_FOR_REVIEW="${REQUESTED_SUBMIT_FOR_REVIEW:-false}"
          REQUESTED_SUBMIT_FOR_REVIEW="$EFFECTIVE_SUBMIT_FOR_REVIEW"
          if [ "$REQUESTED_SUBMIT_FOR_REVIEW" != "true" ]; then
            REQUESTED_SUBMIT_FOR_REVIEW="false"
            EFFECTIVE_SUBMIT_FOR_REVIEW="false"
            echo "Review submission disabled by input; checking App Store review state for TestFlight external routing."
          fi
          echo "ENABLE_TESTFLIGHT_EXTERNAL_RELEASE=false" >> "$GITHUB_ENV"

          if [ -z "${IOS_ASC_KEY_ID:-}" ] || [ -z "${IOS_ASC_ISSUER_ID:-}" ] || [ -z "${IOS_ASC_PRIVATE_KEY:-}" ]; then
            echo "::warning::App Store Connect API secrets are missing. Disabling review submission and TestFlight external routing."
            echo "EFFECTIVE_SUBMIT_FOR_REVIEW=false" >> "$GITHUB_ENV"
            exit 0
          fi

          ASC_KEY_ID="$(printf '%s' "$IOS_ASC_KEY_ID" | tr -d '\r\n\t ')"
          ASC_ISSUER_ID="$(printf '%s' "$IOS_ASC_ISSUER_ID" | tr -d '\r\n\t ')"
          ASC_KEY_PATH="$RUNNER_TEMP/ios-asc-key-review-check.p8"
          bash scripts/ci/write-asc-private-key.sh "$IOS_ASC_PRIVATE_KEY" "$ASC_KEY_PATH"

          if ! openssl pkey -in "$ASC_KEY_PATH" -noout >/dev/null 2>&1; then
            echo "::warning::IOS_ASC_PRIVATE_KEY is invalid. Disabling review submission and TestFlight external routing."
            echo "EFFECTIVE_SUBMIT_FOR_REVIEW=false" >> "$GITHUB_ENV"
            exit 0
          fi

          ASC_API_TMP_PREFIX="asc-review"
          source scripts/ci/asc-api-utils.sh

          if ! ASC_TOKEN="$(
            node scripts/ci/generate-asc-jwt.js "$ASC_KEY_ID" "$ASC_ISSUER_ID" "$ASC_KEY_PATH"
          )"; then
            echo "::warning::Failed to generate App Store Connect JWT. Disabling review submission and TestFlight external routing."
            echo "EFFECTIVE_SUBMIT_FOR_REVIEW=false" >> "$GITHUB_ENV"
            exit 0
          fi

          APPSTORE_APP_ID_RESOLVED="${APPSTORE_APP_ID:-}"
          if [ -z "${APPSTORE_APP_ID_RESOLVED}" ]; then
            APP_LOOKUP_JSON_FILE="$RUNNER_TEMP/asc-review-app-lookup.json"
            if api_get "$APP_LOOKUP_JSON_FILE" -G \
              -H "Authorization: Bearer ${ASC_TOKEN}" \
              --data-urlencode "filter[bundleId]=${EXPECTED_BUNDLE_ID}" \
              --data-urlencode "limit=1" \
              "https://api.appstoreconnect.apple.com/v1/apps"; then
              APPSTORE_APP_ID_RESOLVED="$(jq -r '.data[0].id // empty' "$APP_LOOKUP_JSON_FILE")"
            fi
          fi

          if [ -z "${APPSTORE_APP_ID_RESOLVED}" ]; then
            echo "::warning::App lookup returned no App Store Connect app. Disabling review submission and TestFlight external routing."
            echo "EFFECTIVE_SUBMIT_FOR_REVIEW=false" >> "$GITHUB_ENV"
            exit 0
          fi

          REVIEW_JSON_FILE="$RUNNER_TEMP/asc-review-versions.json"
          if ! api_get "$REVIEW_JSON_FILE" -G \
            -H "Authorization: Bearer ${ASC_TOKEN}" \
            --data-urlencode "filter[appStoreState]=WAITING_FOR_REVIEW,IN_REVIEW" \
            --data-urlencode "filter[platform]=IOS" \
            --data-urlencode "limit=1" \
            "https://api.appstoreconnect.apple.com/v1/apps/${APPSTORE_APP_ID_RESOLVED}/appStoreVersions"; then
            echo "::warning::Review-state lookup failed. Disabling review submission and TestFlight external routing."
            echo "EFFECTIVE_SUBMIT_FOR_REVIEW=false" >> "$GITHUB_ENV"
            exit 0
          fi

          ACTIVE_REVIEW_ID="$(jq -r '.data[0].id // empty' "$REVIEW_JSON_FILE")"
          ACTIVE_REVIEW_VERSION="$(jq -r '.data[0].attributes.versionString // empty' "$REVIEW_JSON_FILE")"
          ACTIVE_REVIEW_STATE="$(jq -r '.data[0].attributes.appStoreState // empty' "$REVIEW_JSON_FILE")"
          if [ -n "${ACTIVE_REVIEW_ID}" ]; then
            echo "::warning::Found existing iOS App Store submission in state ${ACTIVE_REVIEW_STATE:-unknown} (version ${ACTIVE_REVIEW_VERSION:-unknown}). Upload will proceed, but review submission is disabled."
            echo "EFFECTIVE_SUBMIT_FOR_REVIEW=false" >> "$GITHUB_ENV"
            echo "ENABLE_TESTFLIGHT_EXTERNAL_RELEASE=true" >> "$GITHUB_ENV"
            exit 0
          fi

          if [ "$REQUESTED_SUBMIT_FOR_REVIEW" = "true" ]; then
            echo "EFFECTIVE_SUBMIT_FOR_REVIEW=true" >> "$GITHUB_ENV"
            echo "No active App Store review submission found; review submission remains enabled."
          else
            echo "EFFECTIVE_SUBMIT_FOR_REVIEW=false" >> "$GITHUB_ENV"
            echo "No active App Store review submission found; submit_for_review remains disabled."
          fi

      - name: Upload IPA to App Store Connect
        if: ${{ inputs.upload }}
        timeout-minutes: 30
        env:
          IOS_ASC_KEY_ID: ${{ secrets.IOS_ASC_KEY_ID }}
          IOS_ASC_ISSUER_ID: ${{ secrets.IOS_ASC_ISSUER_ID }}
          IOS_ASC_PRIVATE_KEY: ${{ secrets.IOS_ASC_PRIVATE_KEY }}
          SUBMIT_FOR_REVIEW: ${{ env.EFFECTIVE_SUBMIT_FOR_REVIEW || 'false' }}
          FASTLANE_SKIP_UPDATE_CHECK: "1"
          FASTLANE_HIDE_CHANGELOG: "1"
          FASTLANE_OPT_OUT_USAGE: "1"
          CI: "true"
        run: |
          set -euo pipefail

          ASC_KEY_PATH="$RUNNER_TEMP/ios-asc-key-fastlane.p8"
          bash scripts/ci/write-asc-private-key.sh "$IOS_ASC_PRIVATE_KEY" "$ASC_KEY_PATH"

          mkdir -p fastlane
          cat <<'EOF' > fastlane/Fastfile
          opt_out_usage
          default_platform(:ios)

          platform :ios do
            lane :upload_app_store do
              api_key = app_store_connect_api_key(
                key_id: ENV.fetch("IOS_ASC_KEY_ID"),
                issuer_id: ENV.fetch("IOS_ASC_ISSUER_ID"),
                key_filepath: ENV.fetch("ASC_KEY_PATH"),
                duration: 1200,
                in_house: false
              )

              deliver(
                api_key: api_key,
                ipa: ENV.fetch("IPA_PATH"),
                app_version: ENV.fetch("APP_VERSION"),
                metadata_path: ENV.fetch("FASTLANE_METADATA_PATH"),
                skip_screenshots: true,
                skip_app_version_update: false,
                force: true,
                run_precheck_before_submit: false,
                submit_for_review: ENV.fetch("SUBMIT_FOR_REVIEW", "false") == "true",
                automatic_release: true
              )
            end
          end
          EOF

          ASC_KEY_PATH="$ASC_KEY_PATH" fastlane ios upload_app_store

      - name: Distribute upload to TestFlight external group
        if: ${{ inputs.upload }}
        timeout-minutes: 30
        env:
          IOS_ASC_KEY_ID: ${{ secrets.IOS_ASC_KEY_ID }}
          IOS_ASC_ISSUER_ID: ${{ secrets.IOS_ASC_ISSUER_ID }}
          IOS_ASC_PRIVATE_KEY: ${{ secrets.IOS_ASC_PRIVATE_KEY }}
          TESTFLIGHT_EXTERNAL_GROUP: ${{ inputs.testflight_group || 'external_testing' }}
          FASTLANE_SKIP_UPDATE_CHECK: "1"
          FASTLANE_HIDE_CHANGELOG: "1"
          FASTLANE_OPT_OUT_USAGE: "1"
          CI: "true"
        run: |
          set -euo pipefail

          ASC_KEY_PATH="$RUNNER_TEMP/ios-asc-key-fastlane-testflight.p8"
          bash scripts/ci/write-asc-private-key.sh "$IOS_ASC_PRIVATE_KEY" "$ASC_KEY_PATH"

          WHAT_TO_TEST_FILE="metadata/en-US/release_notes.txt"
          DEFAULT_WHAT_TO_TEST="Bug fixes, performance improvements, and sync stability updates."
          WHAT_TO_TEST=""
          if [ -f "$WHAT_TO_TEST_FILE" ]; then
            WHAT_TO_TEST="$(tr '\n' ' ' < "$WHAT_TO_TEST_FILE" | sed 's/[[:space:]]\+/ /g; s/^ //; s/ $//')"
          fi
          if [ -z "${WHAT_TO_TEST}" ]; then
            WHAT_TO_TEST="$DEFAULT_WHAT_TO_TEST"
          fi
          export TESTFLIGHT_WHAT_TO_TEST="$WHAT_TO_TEST"
          echo "Using TestFlight What to Test: ${TESTFLIGHT_WHAT_TO_TEST}"

          mkdir -p fastlane
          cat <<'EOF' > fastlane/Fastfile
          opt_out_usage
          default_platform(:ios)

          platform :ios do
            lane :distribute_external_group do
              beta_review_locked_error = lambda do |error|
                message = error.to_s
                message.match?(/cannot accept new beta review submission/i) ||
                message.match?(/another build.*beta review/i) ||
                  message.match?(/same train.*beta review/i)
              end

              api_key = app_store_connect_api_key(
                key_id: ENV.fetch("IOS_ASC_KEY_ID"),
                issuer_id: ENV.fetch("IOS_ASC_ISSUER_ID"),
                key_filepath: ENV.fetch("ASC_KEY_PATH"),
                duration: 1200,
                in_house: false
              )

              upload_to_testflight(
                api_key: api_key,
                app_identifier: ENV.fetch("EXPECTED_BUNDLE_ID"),
                app_platform: "ios",
                distribute_only: true,
                app_version: ENV.fetch("APP_VERSION"),
                build_number: ENV.fetch("APP_BUILD_NUMBER"),
                distribute_external: true,
                groups: [ENV.fetch("TESTFLIGHT_EXTERNAL_GROUP")],
                notify_external_testers: true,
                changelog: ENV.fetch("TESTFLIGHT_WHAT_TO_TEST"),
                submit_beta_review: true,
                skip_submission: false,
                skip_waiting_for_build_processing: false,
                wait_processing_timeout_duration: 1800
              )
            rescue => e
              if beta_review_locked_error.call(e)
                UI.important("Another TestFlight build is already in beta review for this train. Skipping beta review submission for this run.")
                begin
                  upload_to_testflight(
                    api_key: api_key,
                    app_identifier: ENV.fetch("EXPECTED_BUNDLE_ID"),
                    app_platform: "ios",
                    distribute_only: true,
                    app_version: ENV.fetch("APP_VERSION"),
                    build_number: ENV.fetch("APP_BUILD_NUMBER"),
                    distribute_external: true,
                    groups: [ENV.fetch("TESTFLIGHT_EXTERNAL_GROUP")],
                    notify_external_testers: true,
                    changelog: ENV.fetch("TESTFLIGHT_WHAT_TO_TEST"),
                    submit_beta_review: false,
                    skip_submission: true,
                    skip_waiting_for_build_processing: false,
                    wait_processing_timeout_duration: 1800
                  )
                rescue => retry_error
                  if beta_review_locked_error.call(retry_error)
                    UI.important("Beta review lock is still active. Continuing without failing this workflow.")
                  else
                    raise retry_error
                  end
                end
              else
                raise e
              end
            end
          end
          EOF

          echo "Distributing iOS build ${APP_VERSION} (${APP_BUILD_NUMBER}) to TestFlight group: ${TESTFLIGHT_EXTERNAL_GROUP}"
          ASC_KEY_PATH="$ASC_KEY_PATH" fastlane ios distribute_external_group

      - name: Upload IPA artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: mindwtr-ios-appstore-ipa
          path: ${{ env.IPA_PATH }}
          if-no-files-found: error
          retention-days: 28

      - name: Cleanup signing files
        if: always()
        run: |
          rm -rf fastlane || true
          if [ -n "${KEYCHAIN_PATH:-}" ] && [ -f "${KEYCHAIN_PATH}" ]; then
            security delete-keychain "$KEYCHAIN_PATH" || true
          fi
